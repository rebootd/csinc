<!doctype html>
<!--
  Material Design Lite
  Copyright 2015 Google Inc. All rights reserved.

  Licensed under the Apache License, Version 2.0 (the "License");
  you may not use this file except in compliance with the License.
  You may obtain a copy of the License at

      https://www.apache.org/licenses/LICENSE-2.0

  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License
-->
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="description" content="A front-end template that helps you build fast, modern mobile web apps.">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, minimum-scale=1.0">
    <title>kotlin-coroutines-2019 - Computerist Solutions, Inc</title>
    <meta name="keywords" content="" />
    <meta name="description" content="kotlin-highlights-2019" />

    <!-- Add to homescreen for Chrome on Android -->
    <meta name="mobile-web-app-capable" content="yes">
    <link rel="icon" sizes="192x192" href="images/android-desktop.png">

    <!-- Add to homescreen for Safari on iOS -->
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    <meta name="apple-mobile-web-app-title" content="Material Design Lite">
    <link rel="apple-touch-icon-precomposed" href="images/ios-desktop.png">

    <!-- Tile icon for Win8 (144x144 + tile color) -->
    <meta name="msapplication-TileImage" content="images/touch/ms-touch-icon-144x144-precomposed.png">
    <meta name="msapplication-TileColor" content="#3372DF">

    <link rel="shortcut icon" href="images/favicon.png">

    <!-- SEO: If your mobile URL is different from the desktop URL, add a canonical link to the desktop page https://developers.google.com/webmasters/smartphone-sites/feature-phones -->
    <!--
    <link rel="canonical" href="http://www.example.com/">
    -->

<link rel="stylesheet" href="https://code.getmdl.io/1.3.0/material.indigo-pink.min.css">
<script defer src="https://code.getmdl.io/1.3.0/material.min.js"></script>

    <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:regular,bold,italic,thin,light,bolditalic,black,medium&amp;lang=en">
    <link rel="stylesheet" href="https://fonts.googleapis.com/icon?family=Material+Icons">
    <link rel="stylesheet" href="styles.css">
    <style>
    #view-source {
      position: fixed;
      display: block;
      right: 0;
      bottom: 0;
      margin-right: 40px;
      margin-bottom: 40px;
      z-index: 900;
    }
    </style>
  </head>
  <body>
    <div class="demo-layout mdl-layout mdl-layout--fixed-header mdl-js-layout mdl-color--grey-100">
      <div class="demo-ribbon"></div>
      <main class="demo-main mdl-layout__content">
        <div class="demo-container mdl-grid">
          <div class="mdl-cell mdl-cell--2-col mdl-cell--hide-tablet mdl-cell--hide-phone"></div>
          <div class="demo-content mdl-color--white mdl-shadow--4dp content mdl-color-text--grey-800 mdl-cell mdl-cell--8-col">
		  
            <h1>Welcome, Kotlin/Everywhere Phx 2019!</h1>

<p><img src="https://computeristsolutions.com/images/ke-slides-pic.jpg" alt="really nice KE slides template"></p>

<h2>my goal for this talk</h2>

<p>to give a little overview so we can all see where they are useful and then help each other.</p>

<h2>what are kotlin coroutines</h2>

<ul>
<li>coroutines are like lightweight threads, but not really threads</li>
<li><p>they simplify asynch programming and replace callbacks</p>

<pre><code>// sync code, blocking code
fun loadData() {
    val data = networkRequest()
    show(data)
}

// asynch code with callback
fun loadData() {
    networkRequest { data -&gt;
        show(data)
    }
}

// asynch with coroutines
suspend fun loadData() {
    val data = networkRequest()
    show(data)
}

// still uses new thread, but instad of blocking, it suspends and then resumes the coroutine
</code></pre></li>
<li><p>Parrallel vs asynch.... concurrency vs non-blocking.</p></li>
<li><p>coroutines run asynch and wait for response before completing.</p></li>
<li><p>can be run concurrently but only if you opt-in</p></li>
</ul>

<h2>what are suspending functions</h2>

<ul>
<li>functions that can be suspended and resumed</li>
<li>suspend and resume are direct replacement for callbacks (rxjava, anyone?)</li>
<li><p>kotlin gives us 3 main dispathers</p>

<ul>
<li>Main        -&gt; used by everything</li>
<li>IO          -&gt; used by networks and disk</li>
<li><p>Default     -&gt; CPU .. because it&#39;s also usable on backend, not just android</p>

<p>suspend fun networkRequest() {
    withContext(Dispathers.IO) { // safe with MAIN thread
        /* blocking code */
    }
}</p>

<p>suspend fun loadData() {
    var data = retrofit.networkRequest() // coroutines supported by retrofit
    show(data)
}</p></li>
</ul></li>
<li><p>suspend functions are always MAIN safe</p>

<pre><code>// a kotlin function for starting a suspend function, there are a few
fun getToTheChopper() {
    launch {
        loadData()
    }
}

suspend fun loadData() {
    val data = networkRequest()
    show(data)
}
</code></pre></li>
<li><p>but... who gets to cancel request and who gets exceptions</p></li>
</ul>

<h2>what are scopes</h2>

<ul>
<li><p>scope keeps track of your coroutines</p>

<pre><code>val scope = MainScope()

fun getToTheChopper() {
    scope.launch {
        loadData()
    }
}

suspend fun loadData() {
    val data = networkRequest()
    show(data)
}

fun onClear() {
    super.onCleared()
    scope.cancel()
}
</code></pre></li>
<li><p>NOTE: how to access launchers and dispatchers are evolving and getting simpler</p></li>
<li><p>guarantee: when a suspend function returns it has completed all work</p>

<pre><code>// using coroutineScope dispatches coroutine in the current scope
suspend fun loadLots() {
    coroutineScope {
        repeat(1_000) {
            launch { loadData() }
        }
    }
}

// but that coroutine scope is still active while any coroutine is still running
// which means that coroutineScope only resumes calling coroutine when all 1_000 launched coroutines are finished
</code></pre></li>
<li><p>more scopes increase complexity, can address with structured concurrency</p>

<ul>
<li>return when work is complete</li>
<li>cancelling cancels all children</li>
<li>scope is notified of error</li>
</ul></li>
<li><p>with unstructured concurrency, children continuing running when calling coroutine is cancelled. (um, dragons here)</p></li>
</ul>

<h2>structured concurrency</h2>

<pre><code>    private val updateScope = MainScope()

    suspend fun save(): T {
        val deferred = updateScope.async { // unstructured launch
            withTimeout(TIMEOUT) { // ensure completion or timeout
                mutex.withLock { // consider concurrency
                    api.post() // actual operation
                }
            }
        }

        return deferred.await() // inform caller of the work
    }

    suspend fun save(): T {
        val deferred = updateScope.async { // unstructured
            withTimeout(TIMEOUT) {  // wait until timeout
                mutex.withLock { // concurrency aware
                    api.post() // actual logic to exeute
                }
            }
        }

        return deferred.await()
    }
</code></pre>

<ul>
<li>this is what structured concurrency looks like, but where it&#39;s still improving</li>
</ul>

<h2>what are coroutine builders</h2>

<pre><code>    fun launch(
        context: CoroutineContext = DefaultDispatcher,
        block: suspend () -&gt; Unit): Job { ... }
</code></pre>

<ul>
<li>launch

<ul>
<li>just a normal function that takes as one parameter a block of code that is marked as <em>suspend</em></li>
<li>also returns a handle called <em>Job</em> in case you need a handle for the work</li>
</ul></li>
<li>purposely doesn&#39;t use <em>await</em> keyword because coroutines are designed to imitate <em>sequential</em> behavior so it&#39;s more familiar and clear</li>
<li><p>async</p>

<ul>
<li>just another function that takes a suspend function, and returns a result</li>
<li><p>returns <em>Deferred<T></em> instead of just <em>T</em></p>

<p>fun loadImagesAsync(name: String): Deferred<Image> = async { .. }</p>

<p>val deferred1 = loadImageAsync(name1)
val deferred2 = loadImageAsync(name2)</p>

<p>val image1 = deferred1.await()
val image2 = deferred2.await()</p>

<p>val result = combineImages(image1, image2)</p>

<p>// instead, better kotlin code...</p>

<p>suspend fun loadImage(name: String): Image {}</p>

<p>suspend fun loadAndCombine(name1: String, name2: String): Image {
    val deferred1 = async { loadImage(name1) }
    val deferred2 = async { loadImage(name2) }
    return combineImages(deferred1, deferred2)
}</p></li>
</ul></li>
<li><p>also <code>runBlocking</code> coroutine builder...</p>

<ul>
<li>blocks main thread until its code completes</li>
</ul></li>
<li><p><em>thread</em> is yet another builder...</p></li>
</ul>

<h2>Coroutines are essentially very lightweight threads</h2>

<ul>
<li><p>this runs but blocks main thread from copmleting:</p>

<pre><code>fun main(args: Array&lt;String&gt;) = runBlocking&lt;Unit&gt; {
    val jobs = List(100_000) {
        launch {
            delay(1000L)
            print(&quot;.&quot;)
        }
    }
    jobs.forEach { it.join() }
}
</code></pre></li>
<li><p>the above completes fine, but</p></li>
<li><p>this runs with threading:</p>

<pre><code>fun main(args: Array&lt;String&gt;) {
    val jobs = List(100_000) {
        thread {
            Thread.sleep(1000L)
            print(&quot;.&quot;)
        }
    }
    jobs.forEach { it.join() }
}
</code></pre></li>
<li><p>this will, probably, run out of memory because threads take too much memory</p></li>
<li><p>with threads, you can&#39;t just create, run, and throw away because they are expensive</p></li>
<li><p>with coroutines, you can easily do that and perform asynch or even concurrent operations</p></li>
</ul>

<h2>Java interop with coroutines? Yep!</h2>

<p><code>
CompletableFuture&lt;Image&gt; loadImageAsync(String name) { .. }
CompletableFuture&lt;Image&gt; loadAndCombineAsync(String name1, String name2) { .. }
</code></p>

<pre><code>    /// kotlin
    fun loadAndCombine(name1: String, name2: String): CompletableFuture&lt;Image&gt; = future {
        val future1 = loadImageAsync(name1)
        val future2 = loadImageAsync(name2)
        combineImages(future1.await() future2.await())
    }
</code></pre>

<ul>
<li>the above can be called from Java to leverage Coroutines</li>
<li><em>future</em> is yet another coroutine builder</li>
</ul>

<h2>other things</h2>

<ul>
<li>channels</li>
<li>using <em>yield</em></li>
<li>more concurrency considerations</li>
<li>coroutines is still improving to be easier to use with less boilerplate code</li>
</ul>

<h2>take aways</h2>

<ul>
<li>coroutines make asynch easier to use and to understand</li>
<li><p>kotlin coroutines are still developing AND are here to stay</p></li>
<li><p>use where you have code that needs to start and wait without interrupting rest of your code</p></li>
<li><p>In Android: IO, Network requests, Database operations, image processing</p></li>
<li><p>Server side: IO, Network requests, Database operations, long running processes, maybe streaming operations</p></li>
<li><p>what else can you think of?</p></li>
</ul>

<h2>Thank You!</h2>

<p>Josh Coffman
<a href="https://twitter.com/4spacetabs">https://twitter.com/4spacetabs</a></p>

<p><a href="https://github.com/rebootd">https://github.com/rebootd</a></p>

<p><a href="mailto:joshc@computerist.co">joshc@computerist.co</a></p>

<p><a href="https://computerist.co">https://computerist.co</a></p>

<h4>resources</h4>

<ul>
<li><a href="https://github.com/Kotlin/workshop">https://github.com/Kotlin/workshop</a></li>
<li><a href="https://www.youtube.com/watch?v=jT2gHPQ4Z1Q">https://www.youtube.com/watch?v=jT2gHPQ4Z1Q</a></li>
<li><a href="https://www.youtube.com/watch?v=3FFFW6Q1WIc">https://www.youtube.com/watch?v=3FFFW6Q1WIc</a></li>
<li><a href="https://youtu.be/lh2Vqt4DpHU">https://youtu.be/lh2Vqt4DpHU</a></li>
<li><a href="https://youtu.be/_hfBv0a09Jc">https://youtu.be/_hfBv0a09Jc</a></li>
<li><a href="https://youtu.be/jEavXjZXTac">https://youtu.be/jEavXjZXTac</a></li>
</ul>

            
          </div>
        </div>
        <div class="demo-container mdl-grid font-weight-lighter">
          last update: 2019-09-14 20:38:11 UTC
        </div>
      </main>
    </div>
  </body>
</html>

